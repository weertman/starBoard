
# src/data/best_photo.py
from __future__ import annotations

from pathlib import Path
from typing import List, Optional, Tuple
import json
from datetime import datetime

from .archive_paths import roots_for_read, root_for

_SIDECAR_NAME = ".best_photo.json"


def _candidate_sidecars(target: str, id_str: str) -> List[Path]:
    """Return all plausible sidecar paths for this target/id across all roots (write root first)."""
    out: List[Path] = []
    # Preferred write root first
    try:
        out.append(root_for(target) / id_str / _SIDECAR_NAME)
    except Exception:
        pass
    # Then any readable roots (dedupe)
    seen = {str(p) for p in out}
    for r in roots_for_read(target):
        p = r / id_str / _SIDECAR_NAME
        if str(p) not in seen:
            out.append(p)
            seen.add(str(p))
    return out


def _load_json(path: Path) -> dict:
    try:
        if path.exists():
            return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        pass
    return {}


def _save_json(path: Path, obj: dict) -> None:
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(json.dumps(obj, indent=2, ensure_ascii=False), encoding="utf-8")
    except Exception:
        # Silently ignore IO errors â€” feature is best-effort and should never break the app
        pass


def _best_rel_from_payload(d: dict) -> Optional[str]:
    v = d.get("best_rel") or d.get("best")
    if isinstance(v, str) and v.strip():
        return v.strip().replace("\\\\", "/")
    return None


def load_best_rel_path(target: str, id_str: str) -> Optional[str]:
    """
    Return the stored relative path of the 'best' image for this (target, id),
    e.g. 'encounters/2024-07-01/img_0004.jpg'. If none, returns None.
    Resolves multiple sidecars by preferring the one with the latest 'updated' timestamp,
    otherwise picks the first existing (write root first).
    """
    best: Optional[Tuple[Optional[datetime], str]] = None
    for sidecar in _candidate_sidecars(target, id_str):
        d = _load_json(sidecar)
        rel = _best_rel_from_payload(d)
        if not rel:
            continue
        ts_raw = d.get("updated") or d.get("timestamp")
        ts = None
        try:
            if isinstance(ts_raw, str):
                ts = datetime.fromisoformat(ts_raw.replace("Z", "+00:00"))
        except Exception:
            ts = None
        if best is None or (ts and best[0] and ts > best[0]) or (ts and best[0] is None):
            best = (ts, rel)
        elif best is None:
            best = (None, rel)
    return best[1] if best else None


def save_best_for_id(target: str, id_str: str, image_path: Path) -> None:
    """
    Persist the 'best' image for this (target, id) into a small JSON sidecar living
    at <root_for(target)>/<id>/.best_photo.json, using relative path from the <id> folder.
    """
    # Compute relative path from any plausible base (prefer write root)
    rel_str: Optional[str] = None
    bases = [(root_for(target) / id_str)]
    bases.extend([(r / id_str) for r in roots_for_read(target)])
    for base in bases:
        try:
            rel = image_path.resolve().relative_to(base.resolve())
            rel_str = rel.as_posix()
            break
        except Exception:
            continue
    # Fall back to filename only
    if not rel_str:
        rel_str = image_path.name

    sidecar = root_for(target) / id_str / _SIDECAR_NAME
    payload = {
        "best_rel": rel_str,
        "updated": datetime.utcnow().isoformat() + "Z",
        "note": "Auto-generated by Best Photo feature"
    }
    _save_json(sidecar, payload)


def _match_index_by_suffix(files: List[Path], rel_or_name: str) -> int:
    target = rel_or_name.replace("\\\\", "/").strip("/")
    # Try full suffix match first (path endswith rel path), then basename match
    for i, p in enumerate(files):
        p_norm = str(p).replace("\\\\", "/")
        if p_norm.endswith("/" + target) or p_norm.endswith(target):
            return i
    # Basename match
    base = Path(target).name
    for i, p in enumerate(files):
        if p.name == base:
            return i
    return -1


def reorder_files_with_best(target: str, id_str: str, files: List[Path]) -> List[Path]:
    """
    If a 'best' image is stored for (target, id), rotate the list so that image is first.
    Otherwise return files unchanged.
    """
    try:
        if not files:
            return files
        best_rel = load_best_rel_path(target, id_str)
        if not best_rel:
            return files
        idx = _match_index_by_suffix(files, best_rel)
        if idx <= 0:  # -1 or already first
            return files if idx != -1 else files  # unchanged
        return files[idx:] + files[:idx]
    except Exception:
        # Never break the caller; return original order on any error
        return files
